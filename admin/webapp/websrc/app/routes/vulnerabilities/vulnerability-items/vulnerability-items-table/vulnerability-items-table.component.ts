import {
  ChangeDetectorRef,
  Component,
  EventEmitter,
  Input,
  OnChanges,
  OnDestroy,
  OnInit,
  Output,
  SimpleChanges,
} from '@angular/core';
import {
  CfgType,
  ErrorResponse,
  RemoteGridApi,
  VulQueryOrderByColumnOption,
  VulnerabilitiesQuerySessionData,
  VulnerabilityAsset,
  VulnerabilityProfile,
  VulnerabilityQuery,
  VulnerabilityView,
} from '@common/types';
import {
  ColDef,
  GridApi,
  GridOptions,
  GridReadyEvent,
  IGetRowsParams,
  PaginationChangedEvent,
  ValueFormatterParams,
} from 'ag-grid-community';
import { TranslateService } from '@ngx-translate/core';
import { VulnerabilityItemsTableCsvCellComponent } from './vulnerability-items-table-csv-cell/vulnerability-items-table-csv-cell.component';
import { VulnerabilityItemsTableImpactCellComponent } from './vulnerability-items-table-impact-cell/vulnerability-items-table-impact-cell.component';
import { VulnerabilityItemsTableScoreCellComponent } from './vulnerability-items-table-score-cell/vulnerability-items-table-score-cell.component';
import { VulnerabilityItemsTableSevertiyCellComponent } from './vulnerability-items-table-severtiy-cell/vulnerability-items-table-severtiy-cell.component';
import { VulnerabilitiesService } from '../../vulnerabilities.service';
import { VulnerabilitiesFilterService } from '../../vulnerabilities.filter.service';
import { MatDialog, MatDialogRef } from '@angular/material/dialog';
import { VulnerabilityItemsTableFilterComponent } from './vulnerability-items-table-filter/vulnerability-items-table-filter.component';
import { DatePipe } from '@angular/common';
import { NotificationService } from '@services/notification.service';
import { GlobalVariable } from '@common/variables/global.variable';
import { map, switchMap, tap } from 'rxjs/operators';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-vulnerability-items-table',
  templateUrl: './vulnerability-items-table.component.html',
  styleUrls: ['./vulnerability-items-table.component.scss'],
})
export class VulnerabilityItemsTableComponent
  implements OnInit, OnDestroy, RemoteGridApi
{
  @Output() toggleChartView = new EventEmitter();
  domains!: string[];
  cfgType!: CfgType;
  selectedVulnerability;
  matchTypes = this.vulnerabilitiesFilterService.matchTypes;
  dateTypes = this.vulnerabilitiesFilterService.dateTypes;
  get activeScore() {
    return this.vulnerabilitiesFilterService.selectedScore === 'V2'
      ? this.translate.instant('scan.gridHeader.SCORE_V2')
      : this.translate.instant('scan.gridHeader.SCORE_V3');
  }
  gridOptions!: GridOptions;
  gridApi!: GridApi;
  remoteGridBinding = this;
  filterDialog!: MatDialogRef<any>;
  filterOpen = false;
  get totalCount() {
    return this.vulnerabilitiesService.activeCount;
  }
  get filteredCount() {
    return this.vulnerabilitiesFilterService.filteredCount;
  }
  columnDefs: ColDef[] = [
    {
      field: 'name',
      sortable: true,
      resizable: true,
      headerValueGetter: () => this.translate.instant('scan.gridHeader.NAME'),
    },
    {
      field: 'severity',
      hide: true,
    },
    {
      field: 'score',
      hide: true,
      sortable: true,
      resizable: true,
      cellRenderer: 'scoreCellRenderer',
      cellRendererParams: {
        type: 'V2',
      },
      headerValueGetter: () =>
        this.translate.instant('scan.gridHeader.SCORE_V2'),
      width: 140,
      maxWidth: 140,
      minWidth: 140,
    },
    {
      field: 'score_v3',
      sortable: true,
      resizable: true,
      cellRenderer: 'scoreCellRenderer',
      cellRendererParams: {
        type: 'V3',
      },
      headerValueGetter: () =>
        this.translate.instant('scan.gridHeader.SCORE_V3'),
      width: 140,
      maxWidth: 140,
      minWidth: 140,
    },
    {
      field: 'published_timestamp',
      sortable: true,
      resizable: true,
      valueFormatter: this.dateFormatter,
      headerValueGetter: () =>
        this.translate.instant('scan.gridHeader.PUBLISHED_TIME'),
      width: 130,
      maxWidth: 150,
      minWidth: 130,
    },
    {
      resizable: true,
      cellRenderer: 'impactCellRenderer',
      comparator: this.impactComparator,
      headerValueGetter: () => this.translate.instant('scan.gridHeader.VICTIM'),
    },
    {
      resizable: true,
      cellRenderer: 'csvCellRenderer',
      cellClass: ['d-flex', 'align-items-center'],
      headerValueGetter: () => 'CSV',
      width: 80,
      maxWidth: 80,
      minWidth: 80,
    },
  ];

  constructor(
    private translate: TranslateService,
    private cd: ChangeDetectorRef,
    private vulnerabilitiesService: VulnerabilitiesService,
    private vulnerabilitiesFilterService: VulnerabilitiesFilterService,
    private notificationService: NotificationService,
    public dialog: MatDialog,
    private datePipe: DatePipe
  ) {}

  ngOnInit(): void {
    this.vulnerabilitiesService.getProfileType().subscribe(cfgType => {
      this.cfgType = cfgType;
    });
    this.vulnerabilitiesService.getDomain().subscribe(domains => {
      this.domains = domains;
    });
    this.gridOptions = {
      headerHeight: 30,
      rowHeight: 30,
      columnDefs: this.columnDefs,
      suppressDragLeaveHidesColumns: true,
      rowSelection: 'single',
      pagination: true,
      rowModelType: 'infinite',
      cacheBlockSize: this.vulnerabilitiesFilterService.paginationBlockSize,
      paginationPageSize: this.vulnerabilitiesFilterService.paginationPageSize,
      onGridReady: event => this.onGridReady(event),
      onSelectionChanged: event => this.onSelectionChanged(event),
      components: {
        impactCellRenderer: VulnerabilityItemsTableImpactCellComponent,
        csvCellRenderer: VulnerabilityItemsTableCsvCellComponent,
        scoreCellRenderer: VulnerabilityItemsTableScoreCellComponent,
        severityCellRenderer: VulnerabilityItemsTableSevertiyCellComponent,
      },
      overlayNoRowsTemplate: this.translate.instant('general.NO_ROWS'),
    };
  }

  getData(params: IGetRowsParams) {
    let vulObs: Observable<VulnerabilitiesQuerySessionData>;
    if (params.sortModel.length) {
      vulObs = this.vulnerabilitiesService.getVulnerabilitiesPage(
        params.startRow,
        params.sortModel[0].sort,
        params.sortModel[0].colId as VulQueryOrderByColumnOption
      );
    } else {
      vulObs = this.vulnerabilitiesService.getVulnerabilitiesPage(
        params.startRow
      );
    }
    return vulObs.pipe(
      map(sessionData => {
        return {
          data: sessionData.vulnerabilities,
          totalRecords: this.vulnerabilitiesFilterService.filteredCount,
        };
      })
    );
  }

  acceptVul() {
    const payload: VulnerabilityProfile = {
      entries: [
        {
          name: this.selectedVulnerability.name,
          days: 0,
          comment: `Accepted by ${
            GlobalVariable.user.token.username
          } at ${this.datePipe.transform(
            new Date(),
            'MMM dd, y HH:mm:ss'
          )} from Vulnerabilities page`,
          images: [],
          domains: [],
        },
      ],
      name: 'default',
    };
    this.vulnerabilitiesService.acceptVulnerability(payload).subscribe({
      complete: () => {
        // TODO: Remove accepted vul
        this.vulnerabilitiesService.refresh();
        setTimeout(() => {
          this.gridApi.refreshInfiniteCache();
          this.notificationService.open(
            this.translate.instant('cveProfile.msg.ADD_OK')
          );
        });
      },
      error: ({ error }: { error: ErrorResponse }) => {
        this.notificationService.openError(
          error,
          this.translate.instant('cveProfile.msg.ADD_NG')
        );
      },
    });
  }

  changeScoreView(val: string) {
    this.vulnerabilitiesFilterService.selectedScore = val;
    if (val === 'V2') {
      this.gridOptions.columnApi?.setColumnVisible('score_v3', false);
      this.gridOptions.columnApi?.setColumnVisible('score', true);
    } else {
      this.gridOptions.columnApi?.setColumnVisible('score', false);
      this.gridOptions.columnApi?.setColumnVisible('score_v3', true);
    }
    this.gridApi.sizeColumnsToFit();
    this.cd.markForCheck();
  }

  onGridReady(params): void {
    this.gridApi = params.api;
    this.vulnerabilitiesService.gridApi = this.gridApi;
    setTimeout(() => {
      this.changeScoreView(this.vulnerabilitiesFilterService.selectedScore);
      this.gridApi.sizeColumnsToFit();
      this.cd.markForCheck();
    }, 200);
  }

  filterCountChanged(results: number) {
    // TODO: Figure out how to deal with quickFilter
  }

  onResize(): void {
    this.gridApi.sizeColumnsToFit();
  }

  onSelectionChanged(params: GridReadyEvent): void {
    this.toggleChartView.emit(false);
    this.selectedVulnerability = params.api.getSelectedNodes()[0].data;
    this.vulnerabilitiesService.selectVulnerability(
      params.api.getSelectedNodes()[0].data
    );
  }

  onToggleChartView() {
    this.toggleChartView.emit();
  }

  openAdvancedFilter(): void {
    if (!this.filterOpen) {
      this.filterOpen = true;
      this.filterDialog = this.dialog.open(
        VulnerabilityItemsTableFilterComponent,
        {
          width: '675px',
          data: {
            filter: this.vulnerabilitiesFilterService.vulQuerySubject$.value,
            domains: this.domains,
          },
          hasBackdrop: false,
          position: { right: '25px', top: '100px' },
        }
      );
      this.filterDialog
        .afterClosed()
        .subscribe((filter: VulnerabilityQuery) => {
          console.log(filter);
          if (filter) {
            this.vulnerabilitiesService.refreshing$.next(true);
            if ((filter as any).reset) {
              this.setAdvancedFilter();
            } else {
              this.setAdvancedFilter(filter);
            }
          }
          this.filterOpen = false;
        });
    }
  }

  setAdvancedFilter(filter?: VulnerabilityQuery) {
    if (filter) {
      this.vulnerabilitiesFilterService.vulQuerySubject$.next({
        ...this.vulnerabilitiesFilterService.vulQuerySubject$.value,
        ...filter,
      });
    } else {
      this.vulnerabilitiesFilterService.vulQuerySubject$.next({
        ...this.vulnerabilitiesFilterService.initVulQuery(),
        viewType:
          this.vulnerabilitiesFilterService.vulQuerySubject$.value.viewType,
      });
    }
  }

  dateFormatter(params: ValueFormatterParams): string {
    if (!params.data) return '';
    const date = new Date(params.data.published_timestamp * 1000);
    const dateString = date.toDateString().split(' ').slice(1);
    dateString[1] = dateString[1] + ',';
    return dateString.join(' ');
  }

  ngOnDestroy() {
    if (this.filterOpen) {
      this.filterDialog.close();
    }
  }

  private impactComparator(value1, value2, node1, node2) {
    const cve1 = node1.data;
    const cve2 = node2.data;
    if (cve1.platforms.length === cve2.platforms.length) {
      if (cve1.images.length === cve2.images.length) {
        if (cve1.nodes.length === cve2.nodes.length) {
          return cve1.workloads.length - cve2.workloads.length;
        } else return cve1.nodes.length - cve2.nodes.length;
      } else return cve1.images.length - cve2.images.length;
    } else {
      return cve1.platforms.length - cve2.platforms.length;
    }
  }
}
